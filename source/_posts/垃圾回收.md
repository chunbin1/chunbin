---
title: 垃圾回收
code_block_shrink: false
date: 2024-07-29 18:03:09
updated: 2024-07-29 18:03:09
excerpt: 介绍浏览器中js的垃圾回收
tags: [浏览器]
---
## 调用栈
调用完成后：
记录当前执行状态的指针（称为 ESP）往下移动，上面的内存为无效内存，会被新的覆盖。

## 堆回收
### 代际假说和分代收集
特点：
1. 大部分对象在内存中存在的时间很短
2. 不死的对象 会获得者更久

### V8垃圾回收
分为`新生区`和`老生区`

#### 工作流程
1. 标记空间中的活动对象和非活动对象
2. 回收非活动对象梭占据的内存。在所有标记完成后，统一清理内存中所有被标记为可回收的对象。
3. （可选）内存整理。副垃圾回收区不会产生内存碎片

#### 新生区
副垃圾回收器回收

##### Scavenge算法：
- 新生代空间对半分
一半是对象区域，一半空闲区域
- 清理操作
新加入的对象会存放在对象区域中，当对象区域快被写满，执行一次垃圾清理操作
1. 标记--首先对象区域垃圾做标记
2. 进入垃圾清理阶段
3. 进过两次垃圾回收还存活的对象，移到老生区--`垃圾晋升`

特点：
- 每次清理操作都会复制，为了执行效率，一般新生区会设置的比较小

#### 老生区 
除老新生区晋升的对象，一些大的对象会直接被分配到老生区

##### 标记-清除算法
{% asset_img 堆回收.png 堆回收 %}


当调用栈改变，调用指针下移，此时遍历调用栈，不会再找到引用了1003地址的变量，标记为垃圾数据。

然后就可以进行清除操作，不过对一块内存进行多次执行标记,会产生内存碎片。

##### 标记-整理算法
与标记-清除算法的标记过程一致，后续不直接对可回收对象进行清理，让`所有存活对象都向一端移动`,然后直接清理端边界以外的内存


## 全停顿
因为js是单线程的，垃圾回收会造成卡顿

解决方法：分解成小任务--增量标记算法

{% asset_img 增量标记算法.png 增量标记算法 %}

## 拓展
### 如何判断内存泄漏
chrome的`Performance`，如果V8 的内存使用量一直在增加，就有可能是某种原因导致了内存泄漏